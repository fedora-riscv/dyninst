commit 874a73ea4 (HEAD -> master, upstream/master)
Author: Stan Cox <scox@redhat.com>
Date:   Mon Nov 1 14:24:07 2021 -0400

    Don't overflow aarch64 float register vector when setting used regs. (#1127)
    
    Do not include the subtype when setting a float register as a used register if the registerSlot vector would be exceeded, e.g. for a value like 0x400 (Q_REG/register 0).

--- dyninst-11.0.1/dyninstAPI/src/inst-aarch64.C.orig
+++ dyninst-11.0.1/dyninstAPI/src/inst-aarch64.C
@@ -551,8 +551,13 @@ bool EmitterAARCH64::clobberAllFuncCall(registerSpace *rs,
             rs->GPRs()[*itr]->beenUsed = true;
 
         std::set<Register> *fpRegs = callee->ifunc()->usedFPRs();
-        for(std::set<Register>::iterator itr = fpRegs->begin(); itr != fpRegs->end(); itr++)
-            rs->FPRs()[*itr]->beenUsed = true;
+        for(std::set<Register>::iterator itr = fpRegs->begin(); itr != fpRegs->end(); itr++) {
+            if (*itr <= rs->FPRs().size())
+              rs->FPRs()[*itr]->beenUsed = true;
+            else
+              // parse_func::calcUsedRegs includes the subtype; we only want the regno
+              rs->FPRs()[*itr & 0xff]->beenUsed = true;
+        }
     } else {
         for(int idx = 0; idx < rs->numGPRs(); idx++)
             rs->GPRs()[idx]->beenUsed = true;
commit b2c892f55
Author: Stan Cox <scox@redhat.com>
Date:   Tue Oct 26 17:43:14 2021 -0400

    Load callee's address when the callee and caller are in the same module (#1056)
    
    If the callee and caller are in the same module and pic is not
    required then the callee's address can be loaded directly without
    using a relocation.

--- dyninst-11.0.0/dyninstAPI/src/inst-aarch64.C.orig
+++ dyninst-11.0.0/dyninstAPI/src/inst-aarch64.C
@@ -651,12 +651,14 @@ Register EmitterAARCH64::emitCall(opCode op,
 
     assert(gen.rs());
 
-    //Address of function to call in scratch register
+    // Address of function to call in scratch register
     Register scratch = gen.rs()->getScratchRegister(gen);
     assert(scratch != REG_NULL && "cannot get a scratch register");
     gen.markRegDefined(scratch);
 
-    if (gen.addrSpace()->edit() != NULL) {
+    if (gen.addrSpace()->edit() != NULL
+	&& (gen.func()->obj() != callee->obj()
+	    || gen.addrSpace()->needsPIC())) {
         // gen.as.edit() checks if we are in rewriter mode
         Address dest = getInterModuleFuncAddr(callee, gen);
 
@@ -666,7 +668,6 @@ Register EmitterAARCH64::emitCall(opCode op,
         instruction insn;
         insn.clear();
         INSN_SET(insn, 31, 31, 0);
-        //INSN_SET(insn, 29, 30, disp & 0x3);
         INSN_SET(insn, 28, 28, 1);
         INSN_SET(insn, 5, 23, disp >> 2);
         INSN_SET(insn, 0, 4, scratch);
